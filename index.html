<script>
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
      navigator.serviceWorker.register("sw.js").catch(() => {});
    });
  }

  function val(id) {
    const x = parseFloat(document.getElementById(id).value);
    return isNaN(x) ? 0 : x;
  }

  function fmt(x, d = 3) {
    if (!isFinite(x)) return "—";
    return x.toFixed(d);
  }

  function calculate() {
    const type = document.getElementById("ctype").value;

    const V = val("V");
    const f = val("f");
    const R = val("R");
    const L = val("L");
    const Cuf = val("C");
    const C = Cuf * 1e-6;

    const w = 2 * Math.PI * f;
    const XL = (L > 0 && f > 0) ? w * L : 0;
    const XC = (C > 0 && f > 0) ? 1 / (w * C) : Infinity;

    let XR = R;

    // OUTPUT VARIABLES
    let IR = 0, IL = 0, IC = 0, IT = 0;
    let Z = 0;
    let theta = 0;
    let PF = 0;

    let Ptrue = 0;
    let PvarL = 0;
    let PvarC = 0;

    let S_load = 0;  
    let S_source = 0;  

    // ---------------------------
    // ------- SERIES ------------
    // ---------------------------

    if (type.includes("series")) {
      let Xnet = 0;
      if (type === "series_RL") Xnet = XL;
      if (type === "series_RC") Xnet = -XC;
      if (type === "series_RLC") Xnet = XL - XC;

      Z = Math.sqrt(R * R + Xnet * Xnet);
      IT = V / Z;

      IR = IT;
      IL = (XL !== 0) ? IT : 0;
      IC = (XC !== Infinity) ? IT : 0;

      theta = Math.atan2(Xnet, R);
      PF = Math.cos(theta);

      Ptrue = V * IT * PF;
      PvarL = (XL > 0) ? V * IT * Math.sin(theta) : 0;
      PvarC = (XC !== Infinity && XC > 0) ? -V * IT * Math.sin(theta) : 0;

      S_load = V * IT;
      S_source = V * IT;
    }


    // ---------------------------
    // ------ PARALLEL -----------
    // ---------------------------

    if (type.includes("parallel")) {
      IR = (R > 0) ? V / R : 0;
      IL = (type.includes("RL") || type.includes("RLC")) && XL > 0 ? V / XL : 0;
      IC = (type.includes("RC") || type.includes("RLC")) && XC !== Infinity ? V / XC : 0;

      let IQ = IL - IC;

      IT = Math.sqrt(IR * IR + IQ * IQ);

      theta = Math.atan2(IQ, IR);
      PF = Math.cos(theta);

      // Apparent power by branches (load)
      S_load = V * Math.sqrt(IR*IR + IL*IL + IC*IC);

      // Apparent power from source
      S_source = V * IT;

      Ptrue = V * IR;
      PvarL = V * IL;
      PvarC = -V * IC;

      // Equivalent impedance for parallel system
      Z = V / IT;
    }

    // Theta in degrees
    let thetaDeg = theta * 180 / Math.PI;

    // ---------------------------
    // PRINT OUTPUT
    // ---------------------------
    let out = "";

    out += `=== INPUTS ===\n`;
    out += `Circuit: ${type.toUpperCase()}\n`;
    out += `V = ${fmt(V)} V\nf = ${fmt(f)} Hz\nR = ${fmt(R)} Ω\nL = ${fmt(L)} H\nC = ${fmt(Cuf)} µF\n\n`;

    out += `=== REACTANCES ===\n`;
    out += `X_L = ${fmt(XL)} Ω\n`;
    out += `X_C = ${XC === Infinity ? "∞" : fmt(XC)} Ω\n\n`;

    out += `=== BRANCH CURRENTS ===\n`;
    out += `I_R = ${fmt(IR)} A\n`;
    out += `I_L = ${fmt(IL)} A\n`;
    out += `I_C = ${fmt(IC)} A\n`;
    out += `I_T = ${fmt(IT)} A\n\n`;

    out += `=== IMPEDANCE ===\n`;
    out += `Z = ${fmt(Z)} Ω\n\n`;

    out += `=== POWER ===\n`;
    out += `P_TRUE = ${fmt(Ptrue)} W\n`;
    out += `P_VAR_L = ${fmt(PvarL)} VAR\n`;
    out += `P_VAR_C = ${fmt(PvarC)} VAR\n`;
    out += `P_APP_LOAD = ${fmt(S_load)} VA\n`;
    out += `P_APP_SOURCE = ${fmt(S_source)} VA\n\n`;

    out += `=== ANGLE & PF ===\n`;
    out += `θ = ${fmt(thetaDeg)}°\n`;
    out += `PF = ${fmt(PF)}\n`;

    document.getElementById("results").textContent = out;
  }
</script>
